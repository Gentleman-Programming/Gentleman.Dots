package trainer

// getRegexLessons returns lessons for the Regex/Search module
func getRegexLessons() []Exercise {
	return []Exercise{
		// Lessons 1-2: /pattern - search forward
		{
			ID:          "regex_001",
			Module:      ModuleRegex,
			Level:       1,
			Type:        ExerciseLesson,
			Code:        []string{"function calculateSum(a, b) {", "  return a + b;", "}", "", "function multiply(x, y) {", "  return x * y;", "}"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Search forward for 'multiply' using / command",
			Solutions:   []string{"/multiply", "/multiply\n", "/mult"},
			Optimal:     "/multiply",
			Hint:        "Type / to start a forward search, then type the pattern",
			Explanation: "The / command initiates a forward search in Vim. Type / followed by your search pattern and press Enter. Vim will jump to the first occurrence of the pattern after the cursor position.",
			TimeoutSecs: 30,
			Points:      10,
		},
		{
			ID:          "regex_002",
			Module:      ModuleRegex,
			Level:       1,
			Type:        ExerciseLesson,
			Code:        []string{"const error = 'Something went wrong';", "console.log(error);", "if (error) {", "  handleError(error);", "}"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Search forward to find the word 'error'",
			Solutions:   []string{"/error", "/error\n", "/err"},
			Optimal:     "/error",
			Hint:        "Use /pattern to search forward - the pattern is 'error'",
			Explanation: "Forward search with / is the most common way to find text in Vim. After typing your pattern and pressing Enter, the cursor jumps to the first match. This is case-sensitive by default.",
			TimeoutSecs: 30,
			Points:      10,
		},
		// Lessons 3-4: ?pattern - search backward
		{
			ID:          "regex_003",
			Module:      ModuleRegex,
			Level:       1,
			Type:        ExerciseLesson,
			Code:        []string{"let total = 0;", "for (let i = 0; i < 10; i++) {", "  total += i;", "}", "console.log(total);"},
			CursorPos:   Position{Line: 4, Col: 0},
			Mission:     "Search backward for 'total' using ? command",
			Solutions:   []string{"?total", "?total\n", "?tot"},
			Optimal:     "?total",
			Hint:        "Type ? to start a backward search, then type the pattern",
			Explanation: "The ? command searches backward from the cursor position. This is useful when you know the text you're looking for is above your current position in the file.",
			TimeoutSecs: 30,
			Points:      10,
		},
		{
			ID:          "regex_004",
			Module:      ModuleRegex,
			Level:       1,
			Type:        ExerciseLesson,
			Code:        []string{"function start() {", "  initialize();", "  run();", "}", "", "function stop() {", "  cleanup();", "}"},
			CursorPos:   Position{Line: 7, Col: 0},
			Mission:     "Search backward to find 'start'",
			Solutions:   []string{"?start", "?start\n", "?sta"},
			Optimal:     "?start",
			Hint:        "Use ?pattern to search backward - you're at the bottom looking up",
			Explanation: "Backward search with ? works exactly like / but in reverse. The cursor jumps to the first match found above the current position. This saves time when navigating large files.",
			TimeoutSecs: 30,
			Points:      10,
		},
		// Lessons 5-6: n / N - next/previous match
		{
			ID:          "regex_005",
			Module:      ModuleRegex,
			Level:       2,
			Type:        ExerciseLesson,
			Code:        []string{"let count = 1;", "count = count + 1;", "count = count * 2;", "console.log(count);", "count = 0;"},
			CursorPos:   Position{Line: 0, Col: 4},
			Mission:     "Type 'n' to jump to the next search match (assumes /count was already searched)",
			Solutions:   []string{"n"},
			Optimal:     "n",
			Hint:        "After a search, n jumps to the next match in the same direction",
			Explanation: "The n command repeats the last search in the same direction. If you searched forward with /, n continues forward. This lets you quickly cycle through all matches without retyping the pattern.",
			TimeoutSecs: 30,
			Points:      15,
		},
		{
			ID:          "regex_006",
			Module:      ModuleRegex,
			Level:       2,
			Type:        ExerciseLesson,
			Code:        []string{"data = fetch();", "process(data);", "validate(data);", "save(data);", "log(data);"},
			CursorPos:   Position{Line: 4, Col: 0},
			Mission:     "Type 'N' to jump to the previous search match (opposite direction)",
			Solutions:   []string{"N"},
			Optimal:     "N",
			Hint:        "N searches in the opposite direction of your last search",
			Explanation: "The N command (uppercase) repeats the last search but in the opposite direction. If you searched forward, N goes backward. This is essential for quickly navigating between matches.",
			TimeoutSecs: 30,
			Points:      15,
		},
		// Lessons 7-8: * - search word under cursor forward
		{
			ID:          "regex_007",
			Module:      ModuleRegex,
			Level:       2,
			Type:        ExerciseLesson,
			Code:        []string{"const value = 10;", "let result = value * 2;", "if (value > 5) {", "  return value;", "}"},
			CursorPos:   Position{Line: 0, Col: 6},
			Mission:     "With cursor on 'value', press * to search for it forward",
			Solutions:   []string{"*"},
			Optimal:     "*",
			Hint:        "* searches forward for the word under the cursor",
			Explanation: "The * command is a powerful shortcut that searches forward for the exact word under the cursor. It automatically adds word boundaries, so searching for 'value' won't match 'values'. Much faster than typing /value!",
			TimeoutSecs: 25,
			Points:      15,
		},
		{
			ID:          "regex_008",
			Module:      ModuleRegex,
			Level:       2,
			Type:        ExerciseLesson,
			Code:        []string{"function getName() {", "  return name;", "}", "let name = 'John';", "console.log(getName());"},
			CursorPos:   Position{Line: 0, Col: 9},
			Mission:     "Press * to search for the word under cursor (finds next 'getName')",
			Solutions:   []string{"*"},
			Optimal:     "*",
			Hint:        "* searches forward for the exact word under cursor",
			Explanation: "Using * on function names is incredibly useful for finding all places where a function is called. The word boundary matching ensures you find exact matches, not partial ones embedded in other words.",
			TimeoutSecs: 25,
			Points:      15,
		},
		// Lessons 9-10: # - search word under cursor backward
		{
			ID:          "regex_009",
			Module:      ModuleRegex,
			Level:       2,
			Type:        ExerciseLesson,
			Code:        []string{"let items = [];", "items.push(1);", "items.push(2);", "console.log(items);", "items = null;"},
			CursorPos:   Position{Line: 4, Col: 0},
			Mission:     "Press # to search backward for the word under cursor ('items')",
			Solutions:   []string{"#"},
			Optimal:     "#",
			Hint:        "# is like * but searches backward instead of forward",
			Explanation: "The # command searches backward for the word under the cursor, the opposite of *. Use it when you want to find previous occurrences of a variable or function name above your current position.",
			TimeoutSecs: 25,
			Points:      15,
		},
		{
			ID:          "regex_010",
			Module:      ModuleRegex,
			Level:       2,
			Type:        ExerciseLesson,
			Code:        []string{"class User {", "  constructor() {}", "  save() {}", "}", "const user = new User();", "user.save();"},
			CursorPos:   Position{Line: 5, Col: 0},
			Mission:     "Find the class definition of 'user' by pressing # on it",
			Solutions:   []string{"#"},
			Optimal:     "#",
			Hint:        "# searches backward - perfect for finding where something was defined",
			Explanation: "# is extremely useful when you see a variable being used and want to jump back to its definition. Combined with n and N, you can quickly navigate between all occurrences of any identifier.",
			TimeoutSecs: 25,
			Points:      15,
		},
		// Lessons 11-12: /\v - very magic mode
		{
			ID:          "regex_011",
			Module:      ModuleRegex,
			Level:       3,
			Type:        ExerciseLesson,
			Code:        []string{"phone: 555-1234", "fax: 555-5678", "cell: 555-9999", "office: 555-0000"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Use very magic mode to search for pattern: /\\v\\d+-\\d+",
			Solutions:   []string{"/\\v\\d+-\\d+", "/\\v\\d{3}-\\d{4}", "/\\v555-\\d+"},
			Optimal:     "/\\v\\d+-\\d+",
			Hint:        "\\v enables 'very magic' mode where special chars work without escaping",
			Explanation: "Very magic mode (\\v) makes Vim regex more like standard regex. Special characters like +, (, ), | work without backslash escaping. /\\v\\d+ matches one or more digits naturally, instead of needing /\\d\\+.",
			TimeoutSecs: 45,
			Points:      20,
		},
		{
			ID:          "regex_012",
			Module:      ModuleRegex,
			Level:       3,
			Type:        ExerciseLesson,
			Code:        []string{"email1@test.com", "user.name@domain.org", "admin@company.net", "support@help.io"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Use very magic to find emails: /\\v\\w+@\\w+",
			Solutions:   []string{"/\\v\\w+@\\w+", "/\\v.+@.+", "/\\v\\w+@"},
			Optimal:     "/\\v\\w+@\\w+",
			Hint:        "\\v lets you use \\w+ (one or more word chars) without extra escaping",
			Explanation: "In very magic mode, common regex patterns work intuitively. \\w+ matches one or more word characters (letters, digits, underscore). Without \\v, you'd need /\\w\\+ which is less readable.",
			TimeoutSecs: 45,
			Points:      20,
		},
		// Lessons 13-15: Basic patterns \d, \w, word boundaries
		{
			ID:          "regex_013",
			Module:      ModuleRegex,
			Level:       3,
			Type:        ExerciseLesson,
			Code:        []string{"user1 has 42 points", "user2 has 100 points", "user3 has 7 points"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Search for any number using /\\d\\+ pattern",
			Solutions:   []string{"/\\d\\+", "/\\d", "/[0-9]\\+"},
			Optimal:     "/\\d\\+",
			Hint:        "\\d matches a digit, \\+ means one or more (escaped + in Vim)",
			Explanation: "\\d is a shorthand for [0-9] and matches any digit. In Vim's default 'magic' mode, you need \\+ for 'one or more'. The pattern \\d\\+ matches numbers like 42, 100, or 7.",
			TimeoutSecs: 40,
			Points:      20,
		},
		{
			ID:          "regex_014",
			Module:      ModuleRegex,
			Level:       3,
			Type:        ExerciseLesson,
			Code:        []string{"var_name = 'test'", "another_var = 123", "myVariable = true", "_private = false"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Search for word characters using /\\w\\+ pattern",
			Solutions:   []string{"/\\w\\+", "/\\w", "/[a-zA-Z_]\\+"},
			Optimal:     "/\\w\\+",
			Hint:        "\\w matches word characters: letters, digits, and underscore",
			Explanation: "\\w is equivalent to [a-zA-Z0-9_] and matches any 'word' character. It's perfect for matching variable names, function names, and identifiers. \\w\\+ matches one or more word characters.",
			TimeoutSecs: 40,
			Points:      20,
		},
		{
			ID:          "regex_015",
			Module:      ModuleRegex,
			Level:       3,
			Type:        ExerciseLesson,
			Code:        []string{"the cat sat on the mat", "category is not cat", "scattered cats everywhere"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Search for exact word 'cat' using word boundaries: /\\<cat\\>",
			Solutions:   []string{"/\\<cat\\>", "/\\<cat\\>"},
			Optimal:     "/\\<cat\\>",
			Hint:        "\\< marks word start, \\> marks word end - matches whole words only",
			Explanation: "Word boundaries (\\< and \\>) ensure you match complete words. /\\<cat\\> finds 'cat' but not 'category' or 'scattered'. This is what * and # use internally when searching for the word under cursor.",
			TimeoutSecs: 45,
			Points:      25,
		},
	}
}

// getRegexPractice converts regex lessons to practice exercises
func getRegexPractice() []Exercise {
	lessons := getRegexLessons()
	practices := make([]Exercise, len(lessons))

	for i, lesson := range lessons {
		practice := lesson
		practice.Type = ExercisePractice
		practice.ID = "regex_p" + lesson.ID[6:] // Convert regex_001 to regex_p001
		practice.TimeoutSecs = lesson.TimeoutSecs - 10
		practice.Points = lesson.Points + 10
		practice.Hint = "" // No hints in practice mode
		practices[i] = practice
	}

	return practices
}

// getRegexBoss returns the boss fight for the Regex module
func getRegexBoss() *BossExercise {
	return &BossExercise{
		ID:     "regex_boss",
		Module: ModuleRegex,
		Name:   "The Pattern Hunter",
		Lives:  3,
		Steps: []BossStep{
			{
				Exercise: Exercise{
					ID:        "regex_boss_step1",
					Module:    ModuleRegex,
					Level:     4,
					Type:      ExerciseBoss,
					Code:      []string{"// The Pattern Hunter's Challenge", "function processData(data) {", "  const id = 12345;", "  const email = 'hunter@patterns.com';", "  const phone = '555-867-5309';", "  ", "  if (data.isValid) {", "    return processData(data.next);", "  }", "  ", "  const data_backup = data;", "  log('Processing data with id:', id);", "  return data;", "}"},
					CursorPos: Position{Line: 0, Col: 0},
					Mission:   "Step 1: Search forward for 'processData' function",
					Solutions: []string{"/processData", "/process"},
					Optimal:   "/processData",
					Hint:      "Use / to search forward",
					Points:    40,
				},
				TimeLimit: 30,
			},
			{
				Exercise: Exercise{
					ID:        "regex_boss_step2",
					Module:    ModuleRegex,
					Level:     4,
					Type:      ExerciseBoss,
					Code:      []string{"// The Pattern Hunter's Challenge", "function processData(data) {", "  const id = 12345;", "  const email = 'hunter@patterns.com';", "  const phone = '555-867-5309';", "  ", "  if (data.isValid) {", "    return processData(data.next);", "  }", "  ", "  const data_backup = data;", "  log('Processing data with id:', id);", "  return data;", "}"},
					CursorPos: Position{Line: 1, Col: 9},
					Mission:   "Step 2: Use * to find the recursive call (cursor on processData)",
					Solutions: []string{"*"},
					Optimal:   "*",
					Hint:      "* searches for word under cursor",
					Points:    40,
				},
				TimeLimit: 25,
			},
			{
				Exercise: Exercise{
					ID:        "regex_boss_step3",
					Module:    ModuleRegex,
					Level:     4,
					Type:      ExerciseBoss,
					Code:      []string{"// The Pattern Hunter's Challenge", "function processData(data) {", "  const id = 12345;", "  const email = 'hunter@patterns.com';", "  const phone = '555-867-5309';", "  ", "  if (data.isValid) {", "    return processData(data.next);", "  }", "  ", "  const data_backup = data;", "  log('Processing data with id:', id);", "  return data;", "}"},
					CursorPos: Position{Line: 10, Col: 0},
					Mission:   "Step 3: Search backward with ? to find 'const'",
					Solutions: []string{"?const", "?con"},
					Optimal:   "?const",
					Hint:      "Use ? to search backward",
					Points:    40,
				},
				TimeLimit: 30,
			},
			{
				Exercise: Exercise{
					ID:        "regex_boss_step4",
					Module:    ModuleRegex,
					Level:     4,
					Type:      ExerciseBoss,
					Code:      []string{"// The Pattern Hunter's Challenge", "function processData(data) {", "  const id = 12345;", "  const email = 'hunter@patterns.com';", "  const phone = '555-867-5309';", "  ", "  if (data.isValid) {", "    return processData(data.next);", "  }", "  ", "  const data_backup = data;", "  log('Processing data with id:', id);", "  return data;", "}"},
					CursorPos: Position{Line: 0, Col: 0},
					Mission:   "Step 4: Find the phone number pattern with /\\v\\d+-\\d+-\\d+",
					Solutions: []string{"/\\v\\d+-\\d+-\\d+", "/555-867-5309", "/\\d\\+-\\d\\+-\\d\\+"},
					Optimal:   "/\\v\\d+-\\d+-\\d+",
					Hint:      "Use \\v for very magic mode with regex",
					Points:    40,
				},
				TimeLimit: 45,
			},
			{
				Exercise: Exercise{
					ID:        "regex_boss_step5",
					Module:    ModuleRegex,
					Level:     4,
					Type:      ExerciseBoss,
					Code:      []string{"// The Pattern Hunter's Challenge", "function processData(data) {", "  const id = 12345;", "  const email = 'hunter@patterns.com';", "  const phone = '555-867-5309';", "  ", "  if (data.isValid) {", "    return processData(data.next);", "  }", "  ", "  const data_backup = data;", "  log('Processing data with id:', id);", "  return data;", "}"},
					CursorPos: Position{Line: 0, Col: 0},
					Mission:   "Step 5: Find exact word 'data' (not data_backup) using /\\<data\\>",
					Solutions: []string{"/\\<data\\>"},
					Optimal:   "/\\<data\\>",
					Hint:      "Use word boundaries \\< and \\>",
					Points:    40,
				},
				TimeLimit: 45,
			},
		},
		BonusTime: 120,
	}
}
