package trainer

// getRegexLessons returns lessons for the Regex/Search module
func getRegexLessons() []Exercise {
	return []Exercise{
		// Lessons 1-2: /pattern - search forward
		{
			ID:          "regex_001",
			Module:      ModuleRegex,
			Level:       1,
			Type:        ExerciseLesson,
			Code:        []string{"function calculateSum(a, b) {", "  return a + b;", "}", "", "function multiply(x, y) {", "  return x * y;", "}"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Search forward for 'multiply' using / command",
			Solutions:   []string{"/multiply", "/multiply\n", "/mult"},
			Optimal:     "/multiply",
			Hint:        "Type / to start a forward search, then type the pattern",
			Explanation: "The / command initiates a forward search in Vim. Type / followed by your search pattern and press Enter. Vim will jump to the first occurrence of the pattern after the cursor position.",
			TimeoutSecs: 30,
			Points:      10,
		},
		{
			ID:          "regex_002",
			Module:      ModuleRegex,
			Level:       1,
			Type:        ExerciseLesson,
			Code:        []string{"const error = 'Something went wrong';", "console.log(error);", "if (error) {", "  handleError(error);", "}"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Search forward to find the word 'error'",
			Solutions:   []string{"/error", "/error\n", "/err"},
			Optimal:     "/error",
			Hint:        "Use /pattern to search forward - the pattern is 'error'",
			Explanation: "Forward search with / is the most common way to find text in Vim. After typing your pattern and pressing Enter, the cursor jumps to the first match. This is case-sensitive by default.",
			TimeoutSecs: 30,
			Points:      10,
		},
		// Lessons 3-4: ?pattern - search backward
		{
			ID:          "regex_003",
			Module:      ModuleRegex,
			Level:       1,
			Type:        ExerciseLesson,
			Code:        []string{"let total = 0;", "for (let i = 0; i < 10; i++) {", "  total += i;", "}", "console.log(total);"},
			CursorPos:   Position{Line: 4, Col: 0},
			Mission:     "Search backward for 'total' using ? command",
			Solutions:   []string{"?total", "?total\n", "?tot"},
			Optimal:     "?total",
			Hint:        "Type ? to start a backward search, then type the pattern",
			Explanation: "The ? command searches backward from the cursor position. This is useful when you know the text you're looking for is above your current position in the file.",
			TimeoutSecs: 30,
			Points:      10,
		},
		{
			ID:          "regex_004",
			Module:      ModuleRegex,
			Level:       1,
			Type:        ExerciseLesson,
			Code:        []string{"function start() {", "  initialize();", "  run();", "}", "", "function stop() {", "  cleanup();", "}"},
			CursorPos:   Position{Line: 7, Col: 0},
			Mission:     "Search backward to find 'start'",
			Solutions:   []string{"?start", "?start\n", "?sta"},
			Optimal:     "?start",
			Hint:        "Use ?pattern to search backward - you're at the bottom looking up",
			Explanation: "Backward search with ? works exactly like / but in reverse. The cursor jumps to the first match found above the current position. This saves time when navigating large files.",
			TimeoutSecs: 30,
			Points:      10,
		},
		// Lessons 5-6: n / N - next/previous match
		{
			ID:          "regex_005",
			Module:      ModuleRegex,
			Level:       2,
			Type:        ExerciseLesson,
			Code:        []string{"let count = 1;", "count = count + 1;", "count = count * 2;", "console.log(count);", "count = 0;"},
			CursorPos:   Position{Line: 0, Col: 4},
			Mission:     "Type 'n' to jump to the next search match (assumes /count was already searched)",
			Solutions:   []string{"n"},
			Optimal:     "n",
			Hint:        "After a search, n jumps to the next match in the same direction",
			Explanation: "The n command repeats the last search in the same direction. If you searched forward with /, n continues forward. This lets you quickly cycle through all matches without retyping the pattern.",
			TimeoutSecs: 30,
			Points:      15,
		},
		{
			ID:          "regex_006",
			Module:      ModuleRegex,
			Level:       2,
			Type:        ExerciseLesson,
			Code:        []string{"data = fetch();", "process(data);", "validate(data);", "save(data);", "log(data);"},
			CursorPos:   Position{Line: 4, Col: 0},
			Mission:     "Type 'N' to jump to the previous search match (opposite direction)",
			Solutions:   []string{"N"},
			Optimal:     "N",
			Hint:        "N searches in the opposite direction of your last search",
			Explanation: "The N command (uppercase) repeats the last search but in the opposite direction. If you searched forward, N goes backward. This is essential for quickly navigating between matches.",
			TimeoutSecs: 30,
			Points:      15,
		},
		// Lessons 7-8: * - search word under cursor forward
		{
			ID:          "regex_007",
			Module:      ModuleRegex,
			Level:       2,
			Type:        ExerciseLesson,
			Code:        []string{"const value = 10;", "let result = value * 2;", "if (value > 5) {", "  return value;", "}"},
			CursorPos:   Position{Line: 0, Col: 6},
			Mission:     "With cursor on 'value', press * to search for it forward",
			Solutions:   []string{"*"},
			Optimal:     "*",
			Hint:        "* searches forward for the word under the cursor",
			Explanation: "The * command is a powerful shortcut that searches forward for the exact word under the cursor. It automatically adds word boundaries, so searching for 'value' won't match 'values'. Much faster than typing /value!",
			TimeoutSecs: 25,
			Points:      15,
		},
		{
			ID:          "regex_008",
			Module:      ModuleRegex,
			Level:       2,
			Type:        ExerciseLesson,
			Code:        []string{"function getName() {", "  return name;", "}", "let name = 'John';", "console.log(getName());"},
			CursorPos:   Position{Line: 0, Col: 9},
			Mission:     "Press * to search for the word under cursor (finds next 'getName')",
			Solutions:   []string{"*"},
			Optimal:     "*",
			Hint:        "* searches forward for the exact word under cursor",
			Explanation: "Using * on function names is incredibly useful for finding all places where a function is called. The word boundary matching ensures you find exact matches, not partial ones embedded in other words.",
			TimeoutSecs: 25,
			Points:      15,
		},
		// Lessons 9-10: # - search word under cursor backward
		{
			ID:          "regex_009",
			Module:      ModuleRegex,
			Level:       2,
			Type:        ExerciseLesson,
			Code:        []string{"let items = [];", "items.push(1);", "items.push(2);", "console.log(items);", "items = null;"},
			CursorPos:   Position{Line: 4, Col: 0},
			Mission:     "Press # to search backward for the word under cursor ('items')",
			Solutions:   []string{"#"},
			Optimal:     "#",
			Hint:        "# is like * but searches backward instead of forward",
			Explanation: "The # command searches backward for the word under the cursor, the opposite of *. Use it when you want to find previous occurrences of a variable or function name above your current position.",
			TimeoutSecs: 25,
			Points:      15,
		},
		{
			ID:          "regex_010",
			Module:      ModuleRegex,
			Level:       2,
			Type:        ExerciseLesson,
			Code:        []string{"class User {", "  constructor() {}", "  save() {}", "}", "const user = new User();", "user.save();"},
			CursorPos:   Position{Line: 5, Col: 0},
			Mission:     "Find the class definition of 'user' by pressing # on it",
			Solutions:   []string{"#"},
			Optimal:     "#",
			Hint:        "# searches backward - perfect for finding where something was defined",
			Explanation: "# is extremely useful when you see a variable being used and want to jump back to its definition. Combined with n and N, you can quickly navigate between all occurrences of any identifier.",
			TimeoutSecs: 25,
			Points:      15,
		},
		// Lessons 11-12: /\v - very magic mode
		{
			ID:          "regex_011",
			Module:      ModuleRegex,
			Level:       3,
			Type:        ExerciseLesson,
			Code:        []string{"phone: 555-1234", "fax: 555-5678", "cell: 555-9999", "office: 555-0000"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Use very magic mode to search for pattern: /\\v\\d+-\\d+",
			Solutions:   []string{"/\\v\\d+-\\d+", "/\\v\\d{3}-\\d{4}", "/\\v555-\\d+"},
			Optimal:     "/\\v\\d+-\\d+",
			Hint:        "\\v enables 'very magic' mode where special chars work without escaping",
			Explanation: "Very magic mode (\\v) makes Vim regex more like standard regex. Special characters like +, (, ), | work without backslash escaping. /\\v\\d+ matches one or more digits naturally, instead of needing /\\d\\+.",
			TimeoutSecs: 45,
			Points:      20,
		},
		{
			ID:          "regex_012",
			Module:      ModuleRegex,
			Level:       3,
			Type:        ExerciseLesson,
			Code:        []string{"email1@test.com", "user.name@domain.org", "admin@company.net", "support@help.io"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Use very magic to find emails: /\\v\\w+@\\w+",
			Solutions:   []string{"/\\v\\w+@\\w+", "/\\v.+@.+", "/\\v\\w+@"},
			Optimal:     "/\\v\\w+@\\w+",
			Hint:        "\\v lets you use \\w+ (one or more word chars) without extra escaping",
			Explanation: "In very magic mode, common regex patterns work intuitively. \\w+ matches one or more word characters (letters, digits, underscore). Without \\v, you'd need /\\w\\+ which is less readable.",
			TimeoutSecs: 45,
			Points:      20,
		},
		// Lessons 13-15: Basic patterns \d, \w, word boundaries
		{
			ID:          "regex_013",
			Module:      ModuleRegex,
			Level:       3,
			Type:        ExerciseLesson,
			Code:        []string{"user1 has 42 points", "user2 has 100 points", "user3 has 7 points"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Search for any number using /\\d\\+ pattern",
			Solutions:   []string{"/\\d\\+", "/\\d", "/[0-9]\\+"},
			Optimal:     "/\\d\\+",
			Hint:        "\\d matches a digit, \\+ means one or more (escaped + in Vim)",
			Explanation: "\\d is a shorthand for [0-9] and matches any digit. In Vim's default 'magic' mode, you need \\+ for 'one or more'. The pattern \\d\\+ matches numbers like 42, 100, or 7.",
			TimeoutSecs: 40,
			Points:      20,
		},
		{
			ID:          "regex_014",
			Module:      ModuleRegex,
			Level:       3,
			Type:        ExerciseLesson,
			Code:        []string{"var_name = 'test'", "another_var = 123", "myVariable = true", "_private = false"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Search for word characters using /\\w\\+ pattern",
			Solutions:   []string{"/\\w\\+", "/\\w", "/[a-zA-Z_]\\+"},
			Optimal:     "/\\w\\+",
			Hint:        "\\w matches word characters: letters, digits, and underscore",
			Explanation: "\\w is equivalent to [a-zA-Z0-9_] and matches any 'word' character. It's perfect for matching variable names, function names, and identifiers. \\w\\+ matches one or more word characters.",
			TimeoutSecs: 40,
			Points:      20,
		},
		{
			ID:          "regex_015",
			Module:      ModuleRegex,
			Level:       3,
			Type:        ExerciseLesson,
			Code:        []string{"the cat sat on the mat", "category is not cat", "scattered cats everywhere"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Search for exact word 'cat' using word boundaries: /\\<cat\\>",
			Solutions:   []string{"/\\<cat\\>", "/\\<cat\\>"},
			Optimal:     "/\\<cat\\>",
			Hint:        "\\< marks word start, \\> marks word end - matches whole words only",
			Explanation: "Word boundaries (\\< and \\>) ensure you match complete words. /\\<cat\\> finds 'cat' but not 'category' or 'scattered'. This is what * and # use internally when searching for the word under cursor.",
			TimeoutSecs: 45,
			Points:      25,
		},
		// Lessons 16-17: :vimgrep - search across files
		{
			ID:          "regex_016",
			Module:      ModuleRegex,
			Level:       4,
			Type:        ExerciseLesson,
			Code:        []string{"// Project structure:", "// src/main.js", "// src/utils.js", "// src/api.js", "// Find 'fetchData' in all JS files"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Search for 'fetchData' across all JS files: :vimgrep /fetchData/ **/*.js",
			Solutions:   []string{":vimgrep /fetchData/ **/*.js", ":vimgrep /fetchData/ **/*.js\n", ":vim /fetchData/ **/*.js"},
			Optimal:     ":vimgrep /fetchData/ **/*.js",
			Hint:        ":vimgrep /pattern/ files - searches pattern in multiple files",
			Explanation: ":vimgrep searches for a pattern across multiple files and populates the quickfix list with results. **/*.js is a glob that matches all .js files recursively. This is how you search an entire project!",
			TimeoutSecs: 45,
			Points:      25,
		},
		{
			ID:          "regex_017",
			Module:      ModuleRegex,
			Level:       4,
			Type:        ExerciseLesson,
			Code:        []string{"// Find all TODO comments in project", "// TODO: fix this", "// TODO: refactor later", "// FIXME: urgent bug"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Search for TODO in all files: :vimgrep /TODO/ **/*",
			Solutions:   []string{":vimgrep /TODO/ **/*", ":vimgrep /TODO/ **/*\n", ":vim /TODO/ **/*"},
			Optimal:     ":vimgrep /TODO/ **/*",
			Hint:        "**/* matches all files in all subdirectories",
			Explanation: ":vimgrep is incredibly powerful for project-wide searches. Unlike external grep, it uses Vim's regex engine and integrates with the quickfix list for easy navigation between matches.",
			TimeoutSecs: 45,
			Points:      25,
		},
		// Lessons 18-19: :copen - open quickfix list
		{
			ID:          "regex_018",
			Module:      ModuleRegex,
			Level:       4,
			Type:        ExerciseLesson,
			Code:        []string{"// After :vimgrep, results are in quickfix", "// Open the quickfix window to see them", "function one() {}", "function two() {}", "function three() {}"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Open the quickfix list window with :copen",
			Solutions:   []string{":copen", ":copen\n", ":cope", ":cw"},
			Optimal:     ":copen",
			Hint:        ":copen opens the quickfix window to see all search results",
			Explanation: ":copen opens the quickfix window showing all matches from :vimgrep. You can navigate through results by pressing Enter on any line. The quickfix list persists until you run another search.",
			TimeoutSecs: 30,
			Points:      20,
		},
		{
			ID:          "regex_019",
			Module:      ModuleRegex,
			Level:       4,
			Type:        ExerciseLesson,
			Code:        []string{"// Quickfix list has multiple results:", "// file1.js:10: match one", "// file2.js:25: match two", "// file3.js:42: match three"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Use :cw (short for :cwindow) to open quickfix if there are results",
			Solutions:   []string{":cw", ":cw\n", ":cwindow", ":copen"},
			Optimal:     ":cw",
			Hint:        ":cw is a shorter alias that only opens if there are entries",
			Explanation: ":cw (cwindow) is smarter than :copen - it only opens the quickfix window if there are entries. If the list is empty, it does nothing. Many Vim users map this to a key for quick access.",
			TimeoutSecs: 30,
			Points:      20,
		},
		// Lessons 20-21: :cnext / :cprev - navigate quickfix
		{
			ID:          "regex_020",
			Module:      ModuleRegex,
			Level:       4,
			Type:        ExerciseLesson,
			Code:        []string{"// Current: match 1 of 5", "// Navigate to next match", "const error = 'first';", "const error = 'second';", "const error = 'third';"},
			CursorPos:   Position{Line: 2, Col: 6},
			Mission:     "Jump to the next quickfix entry with :cnext",
			Solutions:   []string{":cnext", ":cnext\n", ":cn"},
			Optimal:     ":cn",
			Hint:        ":cnext (or :cn) jumps to the next match in quickfix list",
			Explanation: ":cnext (:cn for short) jumps to the next entry in the quickfix list, opening the file and positioning the cursor at the match. This is how you efficiently work through search results.",
			TimeoutSecs: 30,
			Points:      20,
		},
		{
			ID:          "regex_021",
			Module:      ModuleRegex,
			Level:       4,
			Type:        ExerciseLesson,
			Code:        []string{"// Current: match 3 of 5", "// Go back to previous match", "const value = 'first';", "const value = 'second';", "const value = 'third';"},
			CursorPos:   Position{Line: 4, Col: 6},
			Mission:     "Jump to the previous quickfix entry with :cprev",
			Solutions:   []string{":cprev", ":cprev\n", ":cp"},
			Optimal:     ":cp",
			Hint:        ":cprev (or :cp) jumps to the previous match",
			Explanation: ":cprev (:cp for short) goes to the previous quickfix entry. Pro tip: map :cn and :cp to keys like ]q and [q for rapid navigation through search results.",
			TimeoutSecs: 30,
			Points:      20,
		},
		// Lessons 22-23: :grep - external grep integration
		{
			ID:          "regex_022",
			Module:      ModuleRegex,
			Level:       5,
			Type:        ExerciseLesson,
			Code:        []string{"// :grep uses external grep program", "// Faster than :vimgrep for large projects", "// Results go to quickfix list too"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Use external grep to find 'import': :grep import **/*.js",
			Solutions:   []string{":grep import **/*.js", ":grep import **/*.js\n", ":gr import **/*.js"},
			Optimal:     ":grep import **/*.js",
			Hint:        ":grep uses your system's grep (or ripgrep if configured)",
			Explanation: ":grep runs an external grep program and populates the quickfix list. It's faster than :vimgrep for large codebases. Set 'grepprg' to use ripgrep (:set grepprg=rg\\ --vimgrep) for best performance!",
			TimeoutSecs: 45,
			Points:      25,
		},
		{
			ID:          "regex_023",
			Module:      ModuleRegex,
			Level:       5,
			Type:        ExerciseLesson,
			Code:        []string{"// Find all console.log statements", "console.log('debug 1');", "console.log('debug 2');", "// Remove before production!"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Search for console.log with :grep 'console.log' **/*.js",
			Solutions:   []string{":grep 'console.log' **/*.js", ":grep console.log **/*.js", ":grep 'console.log' **/*.js\n"},
			Optimal:     ":grep 'console.log' **/*.js",
			Hint:        "Quote patterns with special characters",
			Explanation: "When searching for patterns with dots or special chars, quote them. :grep integrates with the quickfix list just like :vimgrep, so :cn/:cp work the same way after either command.",
			TimeoutSecs: 45,
			Points:      25,
		},
		// Lesson 24: :cclose - close quickfix window
		{
			ID:          "regex_024",
			Module:      ModuleRegex,
			Level:       5,
			Type:        ExerciseLesson,
			Code:        []string{"// Done reviewing search results", "// Close the quickfix window", "function processResults() {", "  // ...code...", "}"},
			CursorPos:   Position{Line: 0, Col: 0},
			Mission:     "Close the quickfix window with :cclose",
			Solutions:   []string{":cclose", ":cclose\n", ":ccl"},
			Optimal:     ":ccl",
			Hint:        ":cclose (or :ccl) closes the quickfix window",
			Explanation: ":cclose closes the quickfix window when you're done reviewing results. The list persists in memory - you can reopen it with :copen anytime. Many users bind :ccl to a key for quick toggle.",
			TimeoutSecs: 30,
			Points:      20,
		},
	}
}

// getRegexPractice converts regex lessons to practice exercises
func getRegexPractice() []Exercise {
	lessons := getRegexLessons()
	practices := make([]Exercise, len(lessons))

	for i, lesson := range lessons {
		practice := lesson
		practice.Type = ExercisePractice
		practice.ID = "regex_p" + lesson.ID[6:] // Convert regex_001 to regex_p001
		practice.TimeoutSecs = lesson.TimeoutSecs - 10
		practice.Points = lesson.Points + 10
		practice.Hint = "" // No hints in practice mode
		practices[i] = practice
	}

	return practices
}

// getRegexBoss returns the boss fight for the Regex module
func getRegexBoss() *BossExercise {
	return &BossExercise{
		ID:     "regex_boss",
		Module: ModuleRegex,
		Name:   "The Pattern Hunter",
		Lives:  3,
		Steps: []BossStep{
			{
				Exercise: Exercise{
					ID:        "regex_boss_step1",
					Module:    ModuleRegex,
					Level:     4,
					Type:      ExerciseBoss,
					Code:      []string{"// The Pattern Hunter's Challenge", "function processData(data) {", "  const id = 12345;", "  const email = 'hunter@patterns.com';", "  const phone = '555-867-5309';", "  ", "  if (data.isValid) {", "    return processData(data.next);", "  }", "  ", "  const data_backup = data;", "  log('Processing data with id:', id);", "  return data;", "}"},
					CursorPos: Position{Line: 0, Col: 0},
					Mission:   "Step 1: Search forward for 'processData' function",
					Solutions: []string{"/processData", "/process"},
					Optimal:   "/processData",
					Hint:      "Use / to search forward",
					Points:    40,
				},
				TimeLimit: 30,
			},
			{
				Exercise: Exercise{
					ID:        "regex_boss_step2",
					Module:    ModuleRegex,
					Level:     4,
					Type:      ExerciseBoss,
					Code:      []string{"// The Pattern Hunter's Challenge", "function processData(data) {", "  const id = 12345;", "  const email = 'hunter@patterns.com';", "  const phone = '555-867-5309';", "  ", "  if (data.isValid) {", "    return processData(data.next);", "  }", "  ", "  const data_backup = data;", "  log('Processing data with id:', id);", "  return data;", "}"},
					CursorPos: Position{Line: 1, Col: 9},
					Mission:   "Step 2: Use * to find the recursive call (cursor on processData)",
					Solutions: []string{"*"},
					Optimal:   "*",
					Hint:      "* searches for word under cursor",
					Points:    40,
				},
				TimeLimit: 25,
			},
			{
				Exercise: Exercise{
					ID:        "regex_boss_step3",
					Module:    ModuleRegex,
					Level:     4,
					Type:      ExerciseBoss,
					Code:      []string{"// The Pattern Hunter's Challenge", "function processData(data) {", "  const id = 12345;", "  const email = 'hunter@patterns.com';", "  const phone = '555-867-5309';", "  ", "  if (data.isValid) {", "    return processData(data.next);", "  }", "  ", "  const data_backup = data;", "  log('Processing data with id:', id);", "  return data;", "}"},
					CursorPos: Position{Line: 10, Col: 0},
					Mission:   "Step 3: Search backward with ? to find 'const'",
					Solutions: []string{"?const", "?con"},
					Optimal:   "?const",
					Hint:      "Use ? to search backward",
					Points:    40,
				},
				TimeLimit: 30,
			},
			{
				Exercise: Exercise{
					ID:        "regex_boss_step4",
					Module:    ModuleRegex,
					Level:     4,
					Type:      ExerciseBoss,
					Code:      []string{"// The Pattern Hunter's Challenge", "function processData(data) {", "  const id = 12345;", "  const email = 'hunter@patterns.com';", "  const phone = '555-867-5309';", "  ", "  if (data.isValid) {", "    return processData(data.next);", "  }", "  ", "  const data_backup = data;", "  log('Processing data with id:', id);", "  return data;", "}"},
					CursorPos: Position{Line: 0, Col: 0},
					Mission:   "Step 4: Find the phone number pattern with /\\v\\d+-\\d+-\\d+",
					Solutions: []string{"/\\v\\d+-\\d+-\\d+", "/555-867-5309", "/\\d\\+-\\d\\+-\\d\\+"},
					Optimal:   "/\\v\\d+-\\d+-\\d+",
					Hint:      "Use \\v for very magic mode with regex",
					Points:    40,
				},
				TimeLimit: 45,
			},
			{
				Exercise: Exercise{
					ID:        "regex_boss_step5",
					Module:    ModuleRegex,
					Level:     4,
					Type:      ExerciseBoss,
					Code:      []string{"// The Pattern Hunter's Challenge", "function processData(data) {", "  const id = 12345;", "  const email = 'hunter@patterns.com';", "  const phone = '555-867-5309';", "  ", "  if (data.isValid) {", "    return processData(data.next);", "  }", "  ", "  const data_backup = data;", "  log('Processing data with id:', id);", "  return data;", "}"},
					CursorPos: Position{Line: 0, Col: 0},
					Mission:   "Step 5: Find exact word 'data' (not data_backup) using /\\<data\\>",
					Solutions: []string{"/\\<data\\>"},
					Optimal:   "/\\<data\\>",
					Hint:      "Use word boundaries \\< and \\>",
					Points:    40,
				},
				TimeLimit: 45,
			},
		},
		BonusTime: 120,
	}
}
